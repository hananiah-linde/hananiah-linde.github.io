[ { "title": "Reference - Connection Strings", "url": "/posts/connection-strings/", "categories": "software", "tags": "database, reference, .net", "date": "2022-08-27 07:30:00 -0500", "snippet": "Connection Strings ReferencePostgre\"Server=localhost; Port=5432; Database=dbname; User Id=postgres; Password=password\"SQL ServerLocal DB - Trusted Connection:\"Server=(localdb)\\\\mssqllocaldb;Database=EfCoreAppSqlServer;Trusted_Connection=True;MultipleActiveResultSets=true\"" }, { "title": "Using Entity Framework Core in Separate Class Library Using SQL Server", "url": "/posts/using-efcore-in-library-sqlserver/", "categories": "software", "tags": "csharp, entityframework, .net", "date": "2022-08-13 16:30:00 -0500", "snippet": "Using Entity Framework Core in Separate Class Library Using SQL ServerIn the post, let’s walk through using Entity Framework Core in a separate class library using SQL Server and an ASP.NET Core WebAPI in .NET 6.I like to get straight to the point of this post so if you want to learn more about Entity Framework, you can check out Microsoft’s documentation here.You can check out the Github repo for this post here.I’m going to use the command line tools to create the project and folder structure instead of using Visual Studio 2022 but if you are following along in VS, feel free to just use that to create the project.Let’s start by creating a Solution file that will hold both the WebAPI and the Class Library projects:I’m using PowerShell in Windows Terminal:dotnet new sln --output EfcoreSqlServerAppThe –output option creates a sln file in a new folder created with the same name. So the result is that we have a folder called EfcoreApp with the file EfcoreApp.sln inside.Change directory into the EfcoreApp folder: cd EfcoreSqlServerAppNow we can add our projects to our Solution. Let’s add the WebAPI project first:dotnet new webapi -o APINow the class library:dotnet new classlib -n DatabaseNow we need to add the two projects to our solution file:dotnet sln add APIdotnet sln add DatabaseLastly, we need to add a reference from our API project to the Class Library:dotnet add API/API.csproj reference Database/Database.csprojNow we can start adding code. I’m using Visual Studio 2022. In this app, we are going to setup ASP.NET Core Identity for the API. This provides us a number of Tables that allow for managing Users in the database. We will have one model that extends the IdentityUser class that is part of ASP.NET Core Identity.Let’s start in the Class Library. The class library template comes with a file called class1.cs. Delete that file and add a new Class called DatabaseContext.cs: namespace Database;public class DataContext{}In order to utilize ASP.NET Core Identity, this class needs to inherit from IdentityDbContext which is part of the Microsoft.AspNetCore.Identity.EntityFrameworkCore namespace. So we need to add the Nuget Package for this.Back in the terminal in the Database folder, run the following command to add the package:dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCoreNow we can inherhit from IdentityDbContext and use IdentityUser as the generic type.Add the following using statements to include the namespaces for those classes:using Microsoft.AspNetCore.Identity;using Microsoft.AspNetCore.Identity.EntityFrameworkCore;namespace Database;public class DatabaseContext : IdentityDbContext&lt;IdentityUser&gt;{}When our API registers the DatabaseContext object (more on that later), it needs a contructor with a DbContextOptions&lt;DatabaseContext&gt; parameter:using Microsoft.AspNetCore.Identity;using Microsoft.AspNetCore.Identity.EntityFrameworkCore;using Microsoft.EntityFrameworkCore;namespace Database;public class DatabaseContext : IdentityDbContext&lt;IdentityUser&gt;{ public DatabaseContext(DbContextOptions options) : base(options) { }}Visual Studio 2022 automatically adding the using statement for Microsoft.EntityFrameworkCore.Now let’s add our Model. I’ll create a folder in the Database project called Entities and add a class named ApiUser.cs there:using Microsoft.AspNetCore.Identity;namespace Database.Entities;public class ApiUser : IdentityUser{ public string FirstName { get; set; } public string LastName { get; set; }}Here’s our model. We’ve extended the IdentityUser class by adding two properties FirstName and LastName which aren’t included in the base class.Now because our DatabaseContext class is inheriting from IdentityDbContext&lt;IdentityUser&gt;, we don't need to add a DbSet&lt;&gt; to register our model like you normal do.So our Database Project is all set for now.Now let’s turn our attention to the API project.There’s two things we need to do. Add EntityFrameworkCore Add ASP.NET Core IdentityI prefer keeping my Program.cs file lean so I’m going to add a new folder that will contain extension methods for adding these services.Add a new folder called Startup and create a class called ServiceExtensions.cs.Add the following code:using Database;using Microsoft.AspNetCore.Identity;namespace API.Startup;public static class ServiceExtensions{ public static void ConfigureEntityFrameworkCore(this IServiceCollection services, IConfiguration configuration) { var connectionString = configuration.GetConnectionString(\"Default\"); services.AddDbContext&lt;DatabaseContext&gt;(options =&gt; options.UseSqlServer(connectionString)); } public static void ConfigureIdentityCore(this IServiceCollection services) { var builder = services.AddIdentityCore&lt;IdentityUser&gt;(q =&gt; q.User.RequireUniqueEmail = true); builder = new IdentityBuilder(builder.UserType, typeof(IdentityRole), services); builder.AddEntityFrameworkStores&lt;DatabaseContext&gt;().AddDefaultTokenProviders(); }}Add the following Nuget Package in the API directory for the missing namespace:dotnet add package Microsoft.EntityFrameworkCore.SqlServerThe ConfigureEntityFrameworkCore extension method will register the DatabaseContext class as a service. We need to supply the connection string to the database. In this demo, I’ve put the connection string in appsettings.json but this is not the best practice for real applications.Add the following to appsettings.json:{ \"ConnectionStrings\": { \"Default\": \"Server=(localdb)\\\\mssqllocaldb;Database=EfCoreAppSqlServer;Trusted_Connection=True;MultipleActiveResultSets=true\" }, \"Logging\": { \"LogLevel\": { \"Default\": \"Information\", \"Microsoft.AspNetCore\": \"Warning\" } }, \"AllowedHosts\": \"*\"}The ConfigureIdentityCore extension method adds ASP.NET Core Identity.In Program.cs we need to call those extension methods in addition to the UseAuthentication():using API.Startup;var builder = WebApplication.CreateBuilder(args);builder.Services.ConfigureEntityFrameworkCore(builder.Configuration);builder.Services.AddAuthentication();builder.Services.ConfigureIdentityCore();builder.Services.AddControllers();builder.Services.AddEndpointsApiExplorer();builder.Services.AddSwaggerGen();var app = builder.Build();app.UseSwagger();app.UseSwaggerUI();app.UseHttpsRedirection();app.UseAuthorization();app.UseAuthentication();app.MapControllers();app.Run();Now we can add out first migration. We need to add the following package to our API project.From the API Directory add the following package:dotnet add package Microsoft.EntityFrameworkCore.DesignNow we can change directory back to Database and run the following command to add our first Migration:dotnet ef migrations add initial --startup-project ..\\API\\API.csprojOutput:Build started...Build succeeded.info: Microsoft.EntityFrameworkCore.Infrastructure[10403] Entity Framework Core 6.0.8 initialized 'DatabaseContext' using provider 'Microsoft.EntityFrameworkCore.SqlServer:6.0.8' with options: NoneDone. To undo this action, use 'ef migrations remove'This created the migration in the Database Project in a folder named Migrations. However, this code is generated by the EF Core tools and does not include all the required packages for the code that was generated.If you look at the DatabaseContextModelSnapshot.cs file, you’ll see that there are some errors. These can be resolved by adding the following packages to the Database project:dotnet add package Microsoft.EntityFrameworkCore.SqlServerNow all the errors have been resolved, let’s update the database:dotnet ef database update --startup-project ..\\API\\API.csprojNow we have successfully separated our DatabaseContext from our UI. This allows us to share the DataContext/EF Core with other projects in the same solution in a clean manner." }, { "title": "Using Entity Framework Core in Separate Class Library Using PostgreSql", "url": "/posts/using-efcore-in-class-library/", "categories": "software", "tags": "csharp, entityframework, .net", "date": "2022-08-13 16:30:00 -0500", "snippet": "Using Entity Framework Core in Separate Class Library Using PostgreSqlIn the post, let’s walk through using Entity Framework Core in a separate class library using Blazor Server as the UI.I like to get straight to the point of this post so if you want to learn more about Entity Framework, you can check out Microsoft’s documentation here.You can check out the Github repo for this post here.I’m going to use the command line tools to create the project and folder structure instead of using Visual Studio 2022 but if you are following along in VS, feel free to just use that to create the project.Let’s start by creating a Solution file that will hold both the Blazor Server project and the Class Library project:I’m using PowerShell in Windows Terminal:dotnet new sln --output EfcoreAppThe –output option creates a sln file in a new folder created with the same name. So the result is that we have a folder called EfcoreApp with the file EfcoreApp.sln inside.Change directory into the EfcoreApp folder: cd EfcoreAppNow we can add our projects to our Solution. Let’s add the Blazor Server project first:dotnet new blazorserver -o BlazorServerUINow the class library:dotnet new classlib -n EfcoreLibraryNow we need to add the two projects to our solution file:dotnet sln add BlazorServerUIdotnet sln add EfcoreLibraryLastly, we need to add a reference from our Blazor Server project to the Class Library:dotnet add BlazorServerUI/BlazorServerUI.csproj reference EfcoreLibrary/EfcoreLibrary.csprojNow we can start adding code. I’m using Visual Studio 2022. This application is going to be a Contacts app. Since this is a blog post about using Ef Core in a separate class library, we aren’t going to build out the application, but we do need a model for our Data Context so it’s helpful to have some context to what we are doing.Let’s start in the Class Library. The class library template comes with a file called class1.cs. Delete that file and add a new Class called DataContext.cs: namespace EfcoreLibrary;public class DataContext{}This class needs to inherit from DbContext which is part of the Microsoft.EntityFrameworkCore namespace. So we need to add the Nuget Package for Microsoft.EntityFrameworkCore.Back in the terminal in the EfcoreLibrary folder, run the following command to add the package:dotnet add package Microsoft.EntityFrameworkCoreNow we can inherhit from DbContext and add the using statement for the namespace:using Microsoft.EntityFrameworkCore;namespace EfcoreLibrary;public class DataContext : DbContext{}When our BlazorServer UI registers the DataContext object (more on that later), it needs a contructor with a DbContextOptions&lt;DataContext&gt; parameter:using Microsoft.EntityFrameworkCore;namespace EfcoreLibrary;public class DataContext : DbContext{ public DataContext(DbContextOptions&lt;DataContext&gt; options) : base(options) { }}Now let’s add our Model. I’ll create a folder in the EfcoreLibrary project called Models and add the Contact class there:namespace EfcoreLibrary.Models;public class Contact{ public int Id { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string PhoneNumber { get; set; } public string Email { get; set; } public string Address { get; set; }}Now let’s add this model to the Context class to register it as an entity:using EfcoreLibrary.Models;using Microsoft.EntityFrameworkCore;namespace EfcoreLibrary;public class DataContext : DbContext{ public DataContext(DbContextOptions&lt;DataContext&gt; options) : base(options) { } public DbSet&lt;Contact&gt; Contacts { get; set; }}For the purposes of this post, I am not going to configure the entity and just let EF define the table. I do not reccomend this for real applications. You should always define/configure the entity to create the table exactly how you need it.Now let’s turn our attention to the UI project. We can start by adding the DbContext as a service in the Program.cs file.In this demo, I’m going to use PostgreSQL for the database. We’ll need to add a few packages from Nuget. Change directory into the BlazorServerUI folder and run the following command:dotnet add package Npgsql.EntityFrameworkCore.PostgreSQLNow let’s add the code to add the DbContext to our services in Program.cs:using BlazorServerUI.Data;using EfcoreLibrary;using Microsoft.EntityFrameworkCore;var builder = WebApplication.CreateBuilder(args);// Add services to the container.builder.Services.AddRazorPages();builder.Services.AddServerSideBlazor();builder.Services.AddSingleton&lt;WeatherForecastService&gt;();builder.Services.AddDbContextFactory&lt;DataContext&gt;(options =&gt;{ options.UseNpgsql(builder.Configuration.GetConnectionString(\"DefaultConnection\"));});Here we are using the AddDbContextFactory instead of AddDbContext becuase we are using Blazor Server. For more information on why we are doing that, you can check out this article.We are also getting the connection string from appsettings.json. Here’s what that looks like:{ \"ConnectionStrings\": { \"DefaultConnection\": \"Server=localhost; Port=5432; Database=DemoEfcore; User Id=postgres; Password=fakepassword\" }}Now we can look at adding out first migration, but before we do that, we need to add a few more NuGet Packages.From the BlazorServerUI Directory add the following package:dotnet add package Microsoft.EntityFrameworkCore.DesignNow we can change directory back to EfcoreLibrary and run the following command to add our first Migration:dotnet ef migrations add initial --startup-project ..\\BlazorServerUI\\BlazorServerUI.csprojOutput:Build started...Build succeeded.info: Microsoft.EntityFrameworkCore.Infrastructure[10403] Entity Framework Core 6.0.8 initialized 'DataContext' using provider 'Npgsql.EntityFrameworkCore.PostgreSQL:6.0.6+6fa8f3c27a7c241a66e72a6c09e0b252509215d0' with options: NoneDone. To undo this action, use 'ef migrations remove'This created the migration in the Libary Project in a folder named Migrations. However, if you go look at the migration, you’ll see that there are a lot of errors in code that was generated and you won’t be able to apply the migration. Trying to apply the migration will result in the following: dotnet ef database update --startup-project ..\\BlazorServerUI\\BlazorServerUI.csprojBuild started...Build failed. Use dotnet build to see the errors.This is because we are still missing a few more Nuget Packages.Let’s add the following the Library project:dotnet add package Microsoft.EntityFrameworkCore.Relationaldotnet add package Npgsql.EntityFrameworkCore.PostgreSQLNow all the build errors have been resolved, let’s update the database:dotnet ef database update --startup-project ..\\BlazorServerUI\\BlazorServerUI.csprojNow we successfully separated our DataContext from our UI. This allows us to share the DataContext/EF Core with other projects in the same solution in a clean manner." }, { "title": "Hello World", "url": "/posts/first-post/", "categories": "software, development", "tags": "csharp", "date": "2022-08-12 17:30:00 -0500", "snippet": "First Blog PostConsole.WriteLine(\"Hello World!\");This is the first blog post I’ve ever written. I’ve always wanted to get into blogging but I never had the motivation to learn a tool or platform like Wordpress or something similar. As a developer, I’m always learning, but I want that learning to be development itself, not Wordpress.The other day, I was poking around in Github and I decided to look into Github Pages just to see what it was capable of. I pulled up Youtube and found this awesome video about using Jekyll with Github Pages to blog.I finally found an easy way to blog without the overhead of learning a new tool. There is very mininmal setup to get this up and running and then after that, you get to use developer tools that we are all familar with (Github, git, VSCode) to write and manage the content.If you are looking for an easy way to start blogging using great tooling and hosting, checkout the video and try it for yourself.Cheers" } ]
